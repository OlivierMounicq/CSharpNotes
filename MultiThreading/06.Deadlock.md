#Deadlock


###How to create a deadlock ?

It's simple!

```cs

void CreateDeadlock()
{
  var ressource1 = new Object();
  var ressource2 = new Object();
  
  var Thread1 = new Thread(delegate() { Work( Ressource1, Ressource2) };
  var Thread2 = new Thread(delegate() { Work( Ressource2, Ressource1) };

  T1.Start();
  T2.Start();
}


void Work(Object acquire, Object demand)
{
  lock(aquire)
  {
    Thread.Sleep(1000) //to ensure that you will get a nice deadlock!
    lock(demand)
    {
      //the code will never use!
    }
  }
}

```

###How to prevent the deadlock ?

#### First method : use a timeout
Instead to use the keyword _lock_ (which is an alias), you should use directly _Monitor_ object.  
So, we can use this code to avoid the deadlock:

```cs
if(Monitor.TryEnter(ressource, 10000))
{
  try
  {
    //Work...
  }
  finally
  {
    Monitor.Exit();
  }
}
else
{
  //Raise an information about the deadlock
}
```

#### Second method : use the pattern _Ressource Acquisition Is Initialization_

The idea is to encapsulate the lock into an object. And when the method using the object has finished, we ensure that the object will be destroyed and in its destructor, we  release the locked ressource.  
So, in the constructor, we lock the ressource and in the destructor, we unlock the ressource (in case if the ressource is still locked).

```cs
public class LockInTheBox : IDisposable
{
  private const Int32 TIMEOUT = 10000;
  private object ressource;
  
  public LockInTheBox(object pRessource)
  {
    if(Monitor.TryEnter(pRessource, TIMEOUT)
    {
      this.ressource = pRessource;
    }
    else
    {
      //raise an information about the deadlock
    }
  }

  public void Dispose()
  {
    if(this.ressource != null)
    {
      Monitor.Exit(this.ressource);
    }
  }
}
```

And we use like this:

```cs
using(new LockInTheBox(myRessource))
{
  //my code
}
```
